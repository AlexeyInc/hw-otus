// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: event.sql

package sqlcstorage

import (
	"context"
	"database/sql"
	"time"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
  title, start_event, end_event, description, id_user, notification
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, title, start_event, end_event, description, id_user, notification, notificationstatus
`

type CreateEventParams struct {
	Title        string         `json:"title"`
	StartEvent   time.Time      `json:"start_event"`
	EndEvent     time.Time      `json:"end_event"`
	Description  sql.NullString `json:"description"`
	IDUser       int64          `json:"id_user"`
	Notification sql.NullTime   `json:"notification"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Title,
		arg.StartEvent,
		arg.EndEvent,
		arg.Description,
		arg.IDUser,
		arg.Notification,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartEvent,
		&i.EndEvent,
		&i.Description,
		&i.IDUser,
		&i.Notification,
		&i.Notificationstatus,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, id)
	return err
}

const deleteExpiredEvents = `-- name: DeleteExpiredEvents :exec
DELETE FROM events 
WHERE now() > end_event + INTERVAL '1 year'
`

func (q *Queries) DeleteExpiredEvents(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredEvents)
	return err
}

const deleteTestEvents = `-- name: DeleteTestEvents :exec
DELETE FROM events WHERE title like '%_test'
`

func (q *Queries) DeleteTestEvents(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteTestEvents)
	return err
}

const getDayEvents = `-- name: GetDayEvents :many
SELECT id, title, start_event, end_event, description, id_user, notification, notificationstatus FROM events
WHERE start_event ::date = cast($1 as date)
ORDER BY start_event
`

func (q *Queries) GetDayEvents(ctx context.Context, dollar_1 time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getDayEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartEvent,
			&i.EndEvent,
			&i.Description,
			&i.IDUser,
			&i.Notification,
			&i.Notificationstatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvent = `-- name: GetEvent :one
SELECT id, title, start_event, end_event, description, id_user, notification, notificationstatus FROM events
WHERE id = $1
`

func (q *Queries) GetEvent(ctx context.Context, id int64) (Event, error) {
	row := q.db.QueryRowContext(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartEvent,
		&i.EndEvent,
		&i.Description,
		&i.IDUser,
		&i.Notification,
		&i.Notificationstatus,
	)
	return i, err
}

const getMonthEvents = `-- name: GetMonthEvents :many
SELECT id, title, start_event, end_event, description, id_user, notification, notificationstatus FROM events
WHERE start_event::date >= cast($1 as date) AND start_event::date < cast($1 as date)::date + interval '1 month'
ORDER BY start_event
`

func (q *Queries) GetMonthEvents(ctx context.Context, dollar_1 time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getMonthEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartEvent,
			&i.EndEvent,
			&i.Description,
			&i.IDUser,
			&i.Notification,
			&i.Notificationstatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotifyEvents = `-- name: GetNotifyEvents :many
SELECT id, title, start_event, end_event, description, id_user, notification, notificationstatus FROM events
WHERE notification <= cast($1 as timestamp) 
  AND start_event > cast($1 as timestamp)
  AND notificationStatus = 0
ORDER BY id
`

func (q *Queries) GetNotifyEvents(ctx context.Context, dollar_1 time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getNotifyEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartEvent,
			&i.EndEvent,
			&i.Description,
			&i.IDUser,
			&i.Notification,
			&i.Notificationstatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeekEvents = `-- name: GetWeekEvents :many
SELECT id, title, start_event, end_event, description, id_user, notification, notificationstatus FROM events
WHERE start_event::date >= cast($1 as date) AND start_event::date < cast($1 as date)::date + interval '7 day'
ORDER BY start_event
`

func (q *Queries) GetWeekEvents(ctx context.Context, dollar_1 time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getWeekEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartEvent,
			&i.EndEvent,
			&i.Description,
			&i.IDUser,
			&i.Notification,
			&i.Notificationstatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events 
SET title =  $2, start_event = $3, end_event = $4, description = $5, id_user = $6, notification = $7
WHERE id = $1
RETURNING id, title, start_event, end_event, description, id_user, notification, notificationstatus
`

type UpdateEventParams struct {
	ID           int64          `json:"id"`
	Title        string         `json:"title"`
	StartEvent   time.Time      `json:"start_event"`
	EndEvent     time.Time      `json:"end_event"`
	Description  sql.NullString `json:"description"`
	IDUser       int64          `json:"id_user"`
	Notification sql.NullTime   `json:"notification"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, updateEvent,
		arg.ID,
		arg.Title,
		arg.StartEvent,
		arg.EndEvent,
		arg.Description,
		arg.IDUser,
		arg.Notification,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartEvent,
		&i.EndEvent,
		&i.Description,
		&i.IDUser,
		&i.Notification,
		&i.Notificationstatus,
	)
	return i, err
}

const updateEventNotificationStatus = `-- name: UpdateEventNotificationStatus :one
UPDATE events 
SET notificationStatus = $1
WHERE id = $2
RETURNING id, title, start_event, end_event, description, id_user, notification, notificationstatus
`

type UpdateEventNotificationStatusParams struct {
	Notificationstatus sql.NullInt32 `json:"notificationstatus"`
	ID                 int64         `json:"id"`
}

func (q *Queries) UpdateEventNotificationStatus(ctx context.Context, arg UpdateEventNotificationStatusParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, updateEventNotificationStatus, arg.Notificationstatus, arg.ID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartEvent,
		&i.EndEvent,
		&i.Description,
		&i.IDUser,
		&i.Notification,
		&i.Notificationstatus,
	)
	return i, err
}
