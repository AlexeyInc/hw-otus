// Code generated by sqlc. DO NOT EDIT.
// source: event.sql

package sqlcstorage

import (
	"context"
	"database/sql"
	"time"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
  title, start_event, end_event, description, id_user
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, title, start_event, end_event, description, id_user
`

type CreateEventParams struct {
	Title       string         `json:"title"`
	StartEvent  time.Time      `json:"start_event"`
	EndEvent    time.Time      `json:"end_event"`
	Description sql.NullString `json:"description"`
	IDUser      int64          `json:"id_user"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Title,
		arg.StartEvent,
		arg.EndEvent,
		arg.Description,
		arg.IDUser,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartEvent,
		&i.EndEvent,
		&i.Description,
		&i.IDUser,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, id)
	return err
}

const deleteTestEvents = `-- name: DeleteTestEvents :exec
DELETE FROM events WHERE title like '%_test'
`

func (q *Queries) DeleteTestEvents(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteTestEvents)
	return err
}

const getDayEvents = `-- name: GetDayEvents :many
SELECT id, title, start_event, end_event, description, id_user FROM events
WHERE start_event ::date = cast($1 as date)
ORDER BY start_event
`

func (q *Queries) GetDayEvents(ctx context.Context, dollar_1 time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getDayEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartEvent,
			&i.EndEvent,
			&i.Description,
			&i.IDUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvent = `-- name: GetEvent :one
SELECT id, title, start_event, end_event, description, id_user FROM events
WHERE id = $1
`

func (q *Queries) GetEvent(ctx context.Context, id int64) (Event, error) {
	row := q.db.QueryRowContext(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartEvent,
		&i.EndEvent,
		&i.Description,
		&i.IDUser,
	)
	return i, err
}

const getMonthEvents = `-- name: GetMonthEvents :many
SELECT id, title, start_event, end_event, description, id_user FROM events
WHERE start_event::date >= cast($1 as date) AND start_event::date < cast($1 as date)::date + interval '1 month'
ORDER BY start_event
`

func (q *Queries) GetMonthEvents(ctx context.Context, dollar_1 time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getMonthEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartEvent,
			&i.EndEvent,
			&i.Description,
			&i.IDUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeekEvents = `-- name: GetWeekEvents :many
SELECT id, title, start_event, end_event, description, id_user FROM events
WHERE start_event::date >= cast($1 as date) AND start_event::date < cast($1 as date)::date + interval '7 day'
ORDER BY start_event
`

func (q *Queries) GetWeekEvents(ctx context.Context, dollar_1 time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getWeekEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartEvent,
			&i.EndEvent,
			&i.Description,
			&i.IDUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events 
SET title =  $2, start_event = $3, end_event = $4, description = $5, id_user = $6
WHERE id = $1
RETURNING id, title, start_event, end_event, description, id_user
`

type UpdateEventParams struct {
	ID          int64          `json:"id"`
	Title       string         `json:"title"`
	StartEvent  time.Time      `json:"start_event"`
	EndEvent    time.Time      `json:"end_event"`
	Description sql.NullString `json:"description"`
	IDUser      int64          `json:"id_user"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, updateEvent,
		arg.ID,
		arg.Title,
		arg.StartEvent,
		arg.EndEvent,
		arg.Description,
		arg.IDUser,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartEvent,
		&i.EndEvent,
		&i.Description,
		&i.IDUser,
	)
	return i, err
}
